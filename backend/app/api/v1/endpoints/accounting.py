"""
Accounting API Endpoints

Provides financial reporting endpoints based on GL Journal Entries:
- Trial Balance
- Inventory Valuation (future)
- Transaction Ledger (future)

These endpoints query actual GL journal entries created by TransactionService.
"""
from datetime import date, datetime, timedelta
from decimal import Decimal
from typing import Optional, List
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy import func, case
from sqlalchemy.orm import Session
from pydantic import BaseModel

from app.db.session import get_db
from app.models.accounting import GLAccount, GLJournalEntry, GLJournalEntryLine, GLFiscalPeriod
from app.models.product import Product
from app.models.inventory import Inventory
from app.api.v1.endpoints.auth import get_current_admin_user
from app.models.user import User

router = APIRouter()


# =============================================================================
# SCHEMAS
# =============================================================================

class TrialBalanceAccount(BaseModel):
    account_code: str
    account_name: str
    account_type: str
    debit_balance: Decimal
    credit_balance: Decimal
    net_balance: Decimal

    class Config:
        from_attributes = True


class TrialBalanceResponse(BaseModel):
    as_of_date: date
    accounts: List[TrialBalanceAccount]
    total_debits: Decimal
    total_credits: Decimal
    is_balanced: bool
    variance: Decimal

    class Config:
        from_attributes = True


# =============================================================================
# INVENTORY VALUATION SCHEMAS
# =============================================================================

class InventoryCategory(BaseModel):
    """Inventory valuation by category"""
    category: str  # Raw Materials, WIP, Finished Goods, Packaging
    gl_account_code: str
    gl_account_name: str
    item_count: int
    total_quantity: Decimal
    inventory_value: Decimal  # Sum of (on_hand * cost) from Inventory table
    gl_balance: Decimal  # Balance from GL journal entries
    variance: Decimal  # inventory_value - gl_balance
    variance_pct: Optional[Decimal] = None  # Variance as percentage

    class Config:
        from_attributes = True


class InventoryValuationResponse(BaseModel):
    """Complete inventory valuation report"""
    as_of_date: date
    categories: List[InventoryCategory]
    total_inventory_value: Decimal
    total_gl_balance: Decimal
    total_variance: Decimal
    is_reconciled: bool  # True if variance < threshold

    class Config:
        from_attributes = True


# =============================================================================
# TRANSACTION LEDGER SCHEMAS
# =============================================================================

class LedgerTransaction(BaseModel):
    """Single transaction in the ledger"""
    entry_date: date
    entry_number: str
    description: str
    debit: Decimal
    credit: Decimal
    running_balance: Decimal
    source_type: Optional[str] = None  # purchase_order, production_order, sales_order, etc.
    source_id: Optional[int] = None
    journal_entry_id: int

    class Config:
        from_attributes = True


class LedgerResponse(BaseModel):
    """Complete ledger for an account"""
    account_code: str
    account_name: str
    account_type: str
    start_date: Optional[date] = None
    end_date: Optional[date] = None
    opening_balance: Decimal
    transactions: List[LedgerTransaction]
    closing_balance: Decimal
    total_debits: Decimal
    total_credits: Decimal
    transaction_count: int

    class Config:
        from_attributes = True


# =============================================================================
# PERIOD MANAGEMENT SCHEMAS
# =============================================================================

class FiscalPeriodResponse(BaseModel):
    """Fiscal period details"""
    id: int
    name: str  # Derived from year/period: "January 2025"
    year: int
    period: int
    start_date: date
    end_date: date
    status: str  # open, closed
    closed_at: Optional[datetime] = None
    closed_by: Optional[str] = None  # User email
    journal_entry_count: int
    total_debits: Decimal
    total_credits: Decimal

    class Config:
        from_attributes = True


class PeriodListResponse(BaseModel):
    """List of fiscal periods"""
    periods: List[FiscalPeriodResponse]
    current_period: Optional[FiscalPeriodResponse] = None

    class Config:
        from_attributes = True


class PeriodCloseRequest(BaseModel):
    """Request to close a period"""
    confirm: bool = False  # Must be True to actually close

    class Config:
        from_attributes = True


class PeriodCloseResponse(BaseModel):
    """Result of period close operation"""
    success: bool
    period_id: int
    period_name: str
    status: str
    message: str
    journal_entry_count: int
    warnings: List[str] = []

    class Config:
        from_attributes = True


# =============================================================================
# DASHBOARD WIDGET SCHEMAS
# =============================================================================

class InventorySummaryItem(BaseModel):
    """Inventory value by category for dashboard"""
    category: str
    value: Decimal
    item_count: int

    class Config:
        from_attributes = True


class AccountingSummaryResponse(BaseModel):
    """Quick financial snapshot for dashboard"""
    as_of_date: date

    # Inventory totals
    total_inventory_value: Decimal
    inventory_by_category: List[InventorySummaryItem]

    # Period info
    current_period: Optional[str] = None
    current_period_status: Optional[str] = None

    # Activity metrics
    entries_today: int
    entries_this_week: int
    entries_this_month: int

    # Balance check
    books_balanced: bool
    variance: Decimal

    class Config:
        from_attributes = True


class RecentEntryItem(BaseModel):
    """Simplified journal entry for dashboard list"""
    id: int
    entry_number: str
    entry_date: date
    description: str
    total_amount: Decimal  # Sum of debits (= sum of credits)
    source_type: Optional[str] = None
    source_id: Optional[int] = None

    class Config:
        from_attributes = True


class RecentEntriesResponse(BaseModel):
    """List of recent journal entries"""
    entries: List[RecentEntryItem]
    total_count: int

    class Config:
        from_attributes = True


# =============================================================================
# ENDPOINTS
# =============================================================================

@router.get(
    "/trial-balance",
    response_model=TrialBalanceResponse,
    summary="Get GL Trial Balance",
    description="Returns the trial balance showing all GL account balances as of a given date."
)
async def get_trial_balance(
    as_of_date: Optional[date] = Query(None, description="Balance as of this date (default: today)"),
    include_zero_balances: bool = Query(False, description="Include accounts with zero balance"),
    db: Session = Depends(get_db),
    current_admin: User = Depends(get_current_admin_user),
):
    """
    Generate a trial balance report.

    The trial balance shows:
    - All GL accounts with their debit/credit balances
    - Total debits and credits (should be equal)
    - Whether the books are balanced

    For asset and expense accounts: normal balance is DEBIT
    For liability, equity, and revenue accounts: normal balance is CREDIT
    """
    if as_of_date is None:
        as_of_date = date.today()

    # Query to sum debits and credits by account
    # Only include journal entries on or before as_of_date
    query = db.query(
        GLAccount.account_code,
        GLAccount.name,
        GLAccount.account_type,
        func.coalesce(func.sum(GLJournalEntryLine.debit_amount), Decimal("0")).label("total_debits"),
        func.coalesce(func.sum(GLJournalEntryLine.credit_amount), Decimal("0")).label("total_credits"),
    ).outerjoin(
        GLJournalEntryLine, GLAccount.id == GLJournalEntryLine.account_id
    ).outerjoin(
        GLJournalEntry, GLJournalEntryLine.journal_entry_id == GLJournalEntry.id
    ).filter(
        # Include accounts with no entries OR entries before as_of_date
        (GLJournalEntry.entry_date <= as_of_date) | (GLJournalEntry.id.is_(None))
    ).group_by(
        GLAccount.id,
        GLAccount.account_code,
        GLAccount.name,
        GLAccount.account_type,
    ).order_by(
        GLAccount.account_code
    )

    results = query.all()

    accounts = []
    total_debits = Decimal("0")
    total_credits = Decimal("0")

    for row in results:
        debit_bal = Decimal(str(row.total_debits or 0))
        credit_bal = Decimal(str(row.total_credits or 0))

        # Calculate net balance based on account type
        # Assets/Expenses: DR increases, CR decreases -> net = DR - CR
        # Liabilities/Equity/Revenue: CR increases, DR decreases -> net = CR - DR
        if row.account_type in ("asset", "expense"):
            net_balance = debit_bal - credit_bal
            # Show as debit balance if positive
            if net_balance >= 0:
                display_debit = net_balance
                display_credit = Decimal("0")
            else:
                display_debit = Decimal("0")
                display_credit = abs(net_balance)
        else:  # liability, equity, revenue
            net_balance = credit_bal - debit_bal
            # Show as credit balance if positive
            if net_balance >= 0:
                display_debit = Decimal("0")
                display_credit = net_balance
            else:
                display_debit = abs(net_balance)
                display_credit = Decimal("0")

        # Skip zero balances unless requested
        if not include_zero_balances and display_debit == 0 and display_credit == 0:
            continue

        accounts.append(TrialBalanceAccount(
            account_code=row.account_code,
            account_name=row.name,
            account_type=row.account_type,
            debit_balance=display_debit,
            credit_balance=display_credit,
            net_balance=net_balance,
        ))

        total_debits += display_debit
        total_credits += display_credit

    variance = abs(total_debits - total_credits)
    is_balanced = variance < Decimal("0.01")  # Allow for rounding

    return TrialBalanceResponse(
        as_of_date=as_of_date,
        accounts=accounts,
        total_debits=total_debits,
        total_credits=total_credits,
        is_balanced=is_balanced,
        variance=variance,
    )


# =============================================================================
# INVENTORY VALUATION ENDPOINT
# =============================================================================

@router.get(
    "/inventory-valuation",
    response_model=InventoryValuationResponse,
    summary="Get Inventory Valuation Report",
    description="Returns inventory value by category compared to GL balances for reconciliation."
)
async def get_inventory_valuation(
    as_of_date: Optional[date] = Query(None, description="Valuation as of this date (default: today)"),
    db: Session = Depends(get_db),
    current_admin: User = Depends(get_current_admin_user),
):
    """
    Generate an inventory valuation report with GL reconciliation.

    Compares:
    - Physical inventory value (sum of on_hand_qty * unit_cost from Inventory/Product)
    - GL balance (sum of journal entry lines for inventory accounts)

    Categories and their GL accounts:
    - Raw Materials -> 1200
    - WIP -> 1210
    - Finished Goods -> 1220
    - Packaging -> 1230

    A variance indicates potential issues:
    - Missing journal entries
    - Double-counted transactions
    - Manual inventory adjustments without GL entries
    """
    if as_of_date is None:
        as_of_date = date.today()

    # Define category mappings
    # item_type -> (category_name, gl_account_code)
    # Note: 'supply' with is_raw_material=True maps to Raw Materials
    category_map = {
        "supply": ("Raw Materials", "1200"),  # Raw materials are stored as supply
        "wip": ("Work in Process", "1210"),
        "finished_good": ("Finished Goods", "1220"),
        "packaging": ("Packaging", "1230"),
    }

    categories = []
    total_inventory_value = Decimal("0")
    total_gl_balance = Decimal("0")

    for item_type, (category_name, gl_code) in category_map.items():
        # Get GL account
        gl_account = db.query(GLAccount).filter(
            GLAccount.account_code == gl_code
        ).first()

        if not gl_account:
            continue

        # Calculate inventory value from physical inventory
        # Sum of (on_hand_quantity * product.standard_cost) for all products of this type
        inventory_query = db.query(
            func.count(Inventory.id).label("item_count"),
            func.coalesce(func.sum(Inventory.on_hand_quantity), Decimal("0")).label("total_qty"),
            func.coalesce(
                func.sum(Inventory.on_hand_quantity * func.coalesce(Product.standard_cost, Decimal("0"))),
                Decimal("0")
            ).label("total_value"),
        ).join(
            Product, Inventory.product_id == Product.id
        ).filter(
            Product.item_type == item_type,
        )

        inv_result = inventory_query.first()

        item_count = inv_result.item_count or 0
        total_qty = Decimal(str(inv_result.total_qty or 0))
        inventory_value = Decimal(str(inv_result.total_value or 0))

        # Calculate GL balance from journal entries up to as_of_date
        gl_query = db.query(
            func.coalesce(func.sum(GLJournalEntryLine.debit_amount), Decimal("0")).label("total_dr"),
            func.coalesce(func.sum(GLJournalEntryLine.credit_amount), Decimal("0")).label("total_cr"),
        ).join(
            GLJournalEntry, GLJournalEntryLine.journal_entry_id == GLJournalEntry.id
        ).filter(
            GLJournalEntryLine.account_id == gl_account.id,
            GLJournalEntry.entry_date <= as_of_date,
        )

        gl_result = gl_query.first()

        total_dr = Decimal(str(gl_result.total_dr or 0))
        total_cr = Decimal(str(gl_result.total_cr or 0))

        # For asset accounts: balance = DR - CR
        gl_balance = total_dr - total_cr

        # Calculate variance
        variance = inventory_value - gl_balance
        variance_pct = None
        if gl_balance != 0:
            variance_pct = (variance / abs(gl_balance)) * 100
        elif inventory_value != 0:
            variance_pct = Decimal("100")  # 100% variance if GL is 0 but inventory exists

        categories.append(InventoryCategory(
            category=category_name,
            gl_account_code=gl_code,
            gl_account_name=gl_account.name,
            item_count=item_count,
            total_quantity=total_qty,
            inventory_value=inventory_value,
            gl_balance=gl_balance,
            variance=variance,
            variance_pct=variance_pct,
        ))

        total_inventory_value += inventory_value
        total_gl_balance += gl_balance

    total_variance = total_inventory_value - total_gl_balance

    # Consider reconciled if variance is less than $1 or 0.1%
    variance_threshold = max(Decimal("1.00"), abs(total_gl_balance) * Decimal("0.001"))
    is_reconciled = abs(total_variance) < variance_threshold

    return InventoryValuationResponse(
        as_of_date=as_of_date,
        categories=categories,
        total_inventory_value=total_inventory_value,
        total_gl_balance=total_gl_balance,
        total_variance=total_variance,
        is_reconciled=is_reconciled,
    )


# =============================================================================
# TRANSACTION LEDGER ENDPOINT
# =============================================================================

@router.get(
    "/ledger/{account_code}",
    response_model=LedgerResponse,
    summary="Get Transaction Ledger",
    description="Returns all transactions for a GL account with running balance."
)
async def get_transaction_ledger(
    account_code: str,
    start_date: Optional[date] = Query(None, description="Filter transactions from this date"),
    end_date: Optional[date] = Query(None, description="Filter transactions to this date"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum transactions to return"),
    offset: int = Query(0, ge=0, description="Offset for pagination"),
    db: Session = Depends(get_db),
    current_admin: User = Depends(get_current_admin_user),
):
    """
    Get the transaction ledger for a specific GL account.

    Shows all journal entry lines affecting this account with:
    - Date and entry number
    - Description
    - Debit/Credit amounts
    - Running balance
    - Source document reference (PO, SO, etc.)

    Use this to:
    - Investigate variances found in inventory valuation
    - Audit transaction history
    - Trace costs through the system
    """
    # Get the account
    account = db.query(GLAccount).filter(
        GLAccount.account_code == account_code
    ).first()

    if not account:
        raise HTTPException(
            status_code=404,
            detail=f"GL Account {account_code} not found"
        )

    # Build base query for transactions
    query = db.query(
        GLJournalEntry.entry_date,
        GLJournalEntry.entry_number,
        GLJournalEntry.description,
        GLJournalEntry.source_type,
        GLJournalEntry.source_id,
        GLJournalEntry.id.label("journal_entry_id"),
        GLJournalEntryLine.debit_amount,
        GLJournalEntryLine.credit_amount,
    ).join(
        GLJournalEntryLine, GLJournalEntry.id == GLJournalEntryLine.journal_entry_id
    ).filter(
        GLJournalEntryLine.account_id == account.id
    )

    # Apply date filters
    if start_date:
        query = query.filter(GLJournalEntry.entry_date >= start_date)
    if end_date:
        query = query.filter(GLJournalEntry.entry_date <= end_date)

    # Order by date, then entry number for consistent ordering
    query = query.order_by(
        GLJournalEntry.entry_date,
        GLJournalEntry.entry_number,
        GLJournalEntry.id,
    )

    # Get total count before pagination
    total_count = query.count()

    # Apply pagination
    results = query.offset(offset).limit(limit).all()

    # Calculate opening balance (all transactions before start_date)
    opening_balance = Decimal("0")
    if start_date:
        opening_query = db.query(
            func.coalesce(func.sum(GLJournalEntryLine.debit_amount), Decimal("0")).label("dr"),
            func.coalesce(func.sum(GLJournalEntryLine.credit_amount), Decimal("0")).label("cr"),
        ).join(
            GLJournalEntry, GLJournalEntryLine.journal_entry_id == GLJournalEntry.id
        ).filter(
            GLJournalEntryLine.account_id == account.id,
            GLJournalEntry.entry_date < start_date,
        )

        opening_result = opening_query.first()
        if opening_result:
            dr = Decimal(str(opening_result.dr or 0))
            cr = Decimal(str(opening_result.cr or 0))
            # For assets/expenses: balance = DR - CR
            # For liabilities/equity/revenue: balance = CR - DR
            if account.account_type in ("asset", "expense"):
                opening_balance = dr - cr
            else:
                opening_balance = cr - dr

    # Build transactions with running balance
    transactions = []
    running_balance = opening_balance
    total_debits = Decimal("0")
    total_credits = Decimal("0")

    for row in results:
        debit = Decimal(str(row.debit_amount or 0))
        credit = Decimal(str(row.credit_amount or 0))

        # Update running balance based on account type
        if account.account_type in ("asset", "expense"):
            running_balance = running_balance + debit - credit
        else:
            running_balance = running_balance + credit - debit

        total_debits += debit
        total_credits += credit

        transactions.append(LedgerTransaction(
            entry_date=row.entry_date,
            entry_number=row.entry_number,
            description=row.description or "",
            debit=debit,
            credit=credit,
            running_balance=running_balance,
            source_type=row.source_type,
            source_id=row.source_id,
            journal_entry_id=row.journal_entry_id,
        ))

    closing_balance = running_balance

    return LedgerResponse(
        account_code=account.account_code,
        account_name=account.name,
        account_type=account.account_type,
        start_date=start_date,
        end_date=end_date,
        opening_balance=opening_balance,
        transactions=transactions,
        closing_balance=closing_balance,
        total_debits=total_debits,
        total_credits=total_credits,
        transaction_count=total_count,
    )


# =============================================================================
# PERIOD MANAGEMENT ENDPOINTS
# =============================================================================

def _get_period_name(year: int, period: int) -> str:
    """Convert year/period to human-readable name like 'January 2025'"""
    import calendar
    return f"{calendar.month_name[period]} {year}"


def _build_period_response(db: Session, period: GLFiscalPeriod) -> FiscalPeriodResponse:
    """Build FiscalPeriodResponse with journal entry stats"""
    # Get journal entry stats for this period
    je_stats = db.query(
        func.count(GLJournalEntry.id).label("count"),
        func.coalesce(func.sum(GLJournalEntryLine.debit_amount), Decimal("0")).label("total_dr"),
        func.coalesce(func.sum(GLJournalEntryLine.credit_amount), Decimal("0")).label("total_cr"),
    ).outerjoin(
        GLJournalEntryLine, GLJournalEntry.id == GLJournalEntryLine.journal_entry_id
    ).filter(
        GLJournalEntry.entry_date >= period.start_date,
        GLJournalEntry.entry_date <= period.end_date,
    ).first()

    # Get closed_by email if applicable
    closed_by_email = None
    if period.closed_by_user:
        closed_by_email = period.closed_by_user.email

    return FiscalPeriodResponse(
        id=period.id,
        name=_get_period_name(period.year, period.period),
        year=period.year,
        period=period.period,
        start_date=period.start_date,
        end_date=period.end_date,
        status=period.status,
        closed_at=period.closed_at,
        closed_by=closed_by_email,
        journal_entry_count=je_stats.count or 0,
        total_debits=Decimal(str(je_stats.total_dr or 0)),
        total_credits=Decimal(str(je_stats.total_cr or 0)),
    )


@router.get(
    "/periods",
    response_model=PeriodListResponse,
    summary="List Fiscal Periods",
    description="Returns all fiscal periods with their status and summary data."
)
async def list_fiscal_periods(
    year: Optional[int] = Query(None, description="Filter by year"),
    status: Optional[str] = Query(None, description="Filter by status: open, closed"),
    db: Session = Depends(get_db),
    current_admin: User = Depends(get_current_admin_user),
):
    """
    List all fiscal periods with summary information.

    Each period shows:
    - Date range
    - Open/closed status
    - Journal entry count and totals
    - Who closed it and when (if closed)
    """
    # Build query
    query = db.query(GLFiscalPeriod)

    if year:
        query = query.filter(GLFiscalPeriod.year == year)

    if status:
        query = query.filter(GLFiscalPeriod.status == status)

    query = query.order_by(GLFiscalPeriod.year.desc(), GLFiscalPeriod.period.desc())
    periods = query.all()

    # Build response with summary data for each period
    period_responses = []
    current_period = None
    today = date.today()

    for period in periods:
        period_resp = _build_period_response(db, period)
        period_responses.append(period_resp)

        # Check if this is the current period
        if period.start_date <= today <= period.end_date:
            current_period = period_resp

    return PeriodListResponse(
        periods=period_responses,
        current_period=current_period,
    )


@router.post(
    "/periods/{period_id}/close",
    response_model=PeriodCloseResponse,
    summary="Close a Fiscal Period",
    description="Close a fiscal period to prevent new entries. Requires confirmation."
)
async def close_fiscal_period(
    period_id: int,
    request: PeriodCloseRequest,
    db: Session = Depends(get_db),
    current_admin: User = Depends(get_current_admin_user),
):
    """
    Close a fiscal period.

    Once closed:
    - No new journal entries can be created in this period
    - Existing entries cannot be modified
    - Period can be reopened by admin if needed

    Before closing, validates:
    - Period exists and is currently open
    - All entries in the period are balanced
    - Confirm flag is True
    """
    # Get the period
    period = db.query(GLFiscalPeriod).filter(GLFiscalPeriod.id == period_id).first()

    if not period:
        raise HTTPException(status_code=404, detail="Fiscal period not found")

    period_name = _get_period_name(period.year, period.period)

    if period.status == "closed":
        raise HTTPException(
            status_code=400,
            detail=f"Period {period_name} is already closed"
        )

    # Get journal entry count
    je_count = db.query(func.count(GLJournalEntry.id)).filter(
        GLJournalEntry.entry_date >= period.start_date,
        GLJournalEntry.entry_date <= period.end_date,
    ).scalar() or 0

    warnings = []

    # Check for unbalanced entries
    unbalanced_query = db.query(
        GLJournalEntry.id,
        GLJournalEntry.entry_number,
        func.sum(GLJournalEntryLine.debit_amount).label("dr"),
        func.sum(GLJournalEntryLine.credit_amount).label("cr"),
    ).join(
        GLJournalEntryLine, GLJournalEntry.id == GLJournalEntryLine.journal_entry_id
    ).filter(
        GLJournalEntry.entry_date >= period.start_date,
        GLJournalEntry.entry_date <= period.end_date,
    ).group_by(
        GLJournalEntry.id, GLJournalEntry.entry_number
    ).having(
        func.abs(func.sum(GLJournalEntryLine.debit_amount) - func.sum(GLJournalEntryLine.credit_amount)) > Decimal("0.01")
    )

    unbalanced = unbalanced_query.all()
    if unbalanced:
        entry_nums = [u.entry_number for u in unbalanced[:5]]  # Show first 5
        warnings.append(f"Warning: {len(unbalanced)} unbalanced entries found: {', '.join(entry_nums)}")

    # If not confirmed, return preview
    if not request.confirm:
        return PeriodCloseResponse(
            success=False,
            period_id=period.id,
            period_name=period_name,
            status="preview",
            message=f"Period {period_name} has {je_count} journal entries. Set confirm=true to close.",
            journal_entry_count=je_count,
            warnings=warnings,
        )

    # Block close if unbalanced entries exist
    if unbalanced:
        raise HTTPException(
            status_code=400,
            detail=f"Cannot close period with {len(unbalanced)} unbalanced entries. Fix entries first."
        )

    # Close the period
    period.status = "closed"
    period.closed_at = datetime.now(timezone.utc)
    period.closed_by = current_admin.id
    db.commit()

    return PeriodCloseResponse(
        success=True,
        period_id=period.id,
        period_name=period_name,
        status="closed",
        message=f"Period {period_name} closed successfully",
        journal_entry_count=je_count,
        warnings=[],
    )


@router.post(
    "/periods/{period_id}/reopen",
    response_model=PeriodCloseResponse,
    summary="Reopen a Closed Period",
    description="Reopen a previously closed fiscal period. Use with caution."
)
async def reopen_fiscal_period(
    period_id: int,
    db: Session = Depends(get_db),
    current_admin: User = Depends(get_current_admin_user),
):
    """
    Reopen a closed fiscal period.

    Use with caution - this allows modifications to historical data.
    Typically used to correct errors discovered after close.
    """
    period = db.query(GLFiscalPeriod).filter(GLFiscalPeriod.id == period_id).first()

    if not period:
        raise HTTPException(status_code=404, detail="Fiscal period not found")

    period_name = _get_period_name(period.year, period.period)

    if period.status == "open":
        raise HTTPException(
            status_code=400,
            detail=f"Period {period_name} is already open"
        )

    # Reopen the period
    period.status = "open"
    period.closed_at = None
    period.closed_by = None
    db.commit()

    # Get entry count for response
    je_count = db.query(func.count(GLJournalEntry.id)).filter(
        GLJournalEntry.entry_date >= period.start_date,
        GLJournalEntry.entry_date <= period.end_date,
    ).scalar() or 0

    return PeriodCloseResponse(
        success=True,
        period_id=period.id,
        period_name=period_name,
        status="open",
        message=f"Period {period_name} reopened successfully",
        journal_entry_count=je_count,
        warnings=["Warning: Historical data can now be modified"],
    )


# =============================================================================
# DASHBOARD WIDGET ENDPOINTS
# =============================================================================

@router.get(
    "/summary",
    response_model=AccountingSummaryResponse,
    summary="Get Accounting Summary",
    description="Quick financial snapshot for the admin dashboard."
)
async def get_accounting_summary(
    db: Session = Depends(get_db),
    current_admin: User = Depends(get_current_admin_user),
):
    """
    Get a quick financial summary for the dashboard.

    Includes:
    - Total inventory value by category
    - Current period status
    - Activity metrics (entries today/week/month)
    - Balance verification
    """
    today = date.today()
    week_ago = today - timedelta(days=7)
    month_start = today.replace(day=1)

    # Inventory by category
    category_map = {
        "material": "Raw Materials",
        "wip": "Work in Process",
        "finished_good": "Finished Goods",
        "packaging": "Packaging",
    }

    inventory_by_category = []
    total_inventory_value = Decimal("0")

    for item_type, category_name in category_map.items():
        inv_query = db.query(
            func.count(Inventory.id).label("count"),
            func.coalesce(
                func.sum(Inventory.on_hand_quantity * Product.standard_cost),
                Decimal("0")
            ).label("value"),
        ).join(
            Product, Inventory.product_id == Product.id
        ).filter(
            Product.item_type == item_type,
            Product.active == True,
        ).first()

        value = Decimal(str(inv_query.value or 0))
        count = inv_query.count or 0

        if value > 0 or count > 0:
            inventory_by_category.append(InventorySummaryItem(
                category=category_name,
                value=value,
                item_count=count,
            ))
            total_inventory_value += value

    # Current period
    current_period = db.query(GLFiscalPeriod).filter(
        GLFiscalPeriod.start_date <= today,
        GLFiscalPeriod.end_date >= today,
    ).first()

    current_period_name = None
    current_period_status = None
    if current_period:
        current_period_name = f"{current_period.year}-{current_period.period:02d}"
        current_period_status = current_period.status

    # Entry counts
    entries_today = db.query(func.count(GLJournalEntry.id)).filter(
        GLJournalEntry.entry_date == today
    ).scalar() or 0

    entries_this_week = db.query(func.count(GLJournalEntry.id)).filter(
        GLJournalEntry.entry_date >= week_ago
    ).scalar() or 0

    entries_this_month = db.query(func.count(GLJournalEntry.id)).filter(
        GLJournalEntry.entry_date >= month_start
    ).scalar() or 0

    # Balance check (sum all debits vs credits)
    balance_query = db.query(
        func.coalesce(func.sum(GLJournalEntryLine.debit_amount), Decimal("0")).label("dr"),
        func.coalesce(func.sum(GLJournalEntryLine.credit_amount), Decimal("0")).label("cr"),
    ).first()

    total_dr = Decimal(str(balance_query.dr or 0))
    total_cr = Decimal(str(balance_query.cr or 0))
    variance = abs(total_dr - total_cr)
    books_balanced = variance < Decimal("0.01")

    return AccountingSummaryResponse(
        as_of_date=today,
        total_inventory_value=total_inventory_value,
        inventory_by_category=inventory_by_category,
        current_period=current_period_name,
        current_period_status=current_period_status,
        entries_today=entries_today,
        entries_this_week=entries_this_week,
        entries_this_month=entries_this_month,
        books_balanced=books_balanced,
        variance=variance,
    )


@router.get(
    "/recent-entries",
    response_model=RecentEntriesResponse,
    summary="Get Recent Journal Entries",
    description="Returns the most recent journal entries for the dashboard."
)
async def get_recent_entries(
    limit: int = Query(10, ge=1, le=50, description="Number of entries to return"),
    db: Session = Depends(get_db),
    current_admin: User = Depends(get_current_admin_user),
):
    """
    Get recent journal entries for dashboard display.

    Returns simplified entry data suitable for a list view.
    """
    # Get total count
    total_count = db.query(func.count(GLJournalEntry.id)).scalar() or 0

    # Get recent entries with their totals
    entries_query = db.query(
        GLJournalEntry.id,
        GLJournalEntry.entry_number,
        GLJournalEntry.entry_date,
        GLJournalEntry.description,
        GLJournalEntry.source_type,
        GLJournalEntry.source_id,
        func.coalesce(func.sum(GLJournalEntryLine.debit_amount), Decimal("0")).label("total_amount"),
    ).outerjoin(
        GLJournalEntryLine, GLJournalEntry.id == GLJournalEntryLine.journal_entry_id
    ).group_by(
        GLJournalEntry.id,
        GLJournalEntry.entry_number,
        GLJournalEntry.entry_date,
        GLJournalEntry.description,
        GLJournalEntry.source_type,
        GLJournalEntry.source_id,
    ).order_by(
        GLJournalEntry.entry_date.desc(),
        GLJournalEntry.id.desc(),
    ).limit(limit)

    results = entries_query.all()

    entries = [
        RecentEntryItem(
            id=row.id,
            entry_number=row.entry_number,
            entry_date=row.entry_date,
            description=row.description or "",
            total_amount=Decimal(str(row.total_amount or 0)),
            source_type=row.source_type,
            source_id=row.source_id,
        )
        for row in results
    ]

    return RecentEntriesResponse(
        entries=entries,
        total_count=total_count,
    )
